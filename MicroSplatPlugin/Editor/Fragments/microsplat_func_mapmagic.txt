   // MapMagic Billboard Functions

   #if _MM2HEIGHT
      float4 _offset;
   #endif
   

   void ConfigureProcedural () {
      #if defined(UNITY_PROCEDURAL_INSTANCING_ENABLED)
         int idx = _FOV[unity_InstanceID];
         _offset = _Offset[idx];
      #endif
   }

   int HeightIdx(in int FMR, in int tileID, int x, int z){
      #if _DownScale <= 1
         return tileID * (FMR * FMR) + (z * FMR + x);
      #endif
      #if _DownScale > 1
         // super simple downscale (heighmap has more values than mesh)
         // so if the mesh is 1/2 the complexity of the HM, we skip every other HM value
         return tileID * (FMR * FMR) + ((z * FMR * _DownScale + x * _DownScale);
      #endif
   }

   float InterpolateEdge(float a, float b){
      return a - (b - a);
   }

   float HeightValue(in int FMR, in int tileID, int x, int z){
      x = x < 0 ? 0 : x;
      x = x > FMR ? FMR: x;
      z = z < 0 ? 0 : z;
      z = z > FMR ? FMR: z;
      return _TerrainValues[HeightIdx(FMR, tileID, x, z)];
   }

   void ApplyNormal(inout VertexData v, in float x, in float z, in int tileID, in int FMR){
      float t = HeightValue(FMR, tileID, x, z);
      float l = x > 0 ? HeightValue(FMR, tileID, x - 1, z): InterpolateEdge(t, HeightValue(FMR, tileID, x + 1, z));
      float r = x < FMR - 1 ? HeightValue(FMR, tileID, x + 1, z): InterpolateEdge(t, HeightValue(FMR, tileID, x - 1, z));
      float u = z > 0 ? HeightValue(FMR, tileID, x, z - 1): InterpolateEdge(t, HeightValue(FMR, tileID, x, z + 1));
      float d = z < FMR - 1 ? HeightValue(FMR, tileID, x, z + 1): InterpolateEdge(t, HeightValue(FMR, tileID, x, z - 1));
      float EPS = FMR / _Mesh_Size;
      v.normal = normalize(float3((l - r) / 2 * EPS, 2 / _Height, (u - d) / 2 * EPS));
   }

///////////////////////
// MS entrypoints
// (you have to plug in this crap yourself, see below)
///////////////////////


// Hooks into microsplat_terrain_core_vertex.txt
// @ ModifyVertex() into the very beginning of the method

   // #if _MM2HEIGHT
   //    MapMagicDisplacement(v);
   // #endif

void MapMagicDisplacement(inout VertexData v)
{
   float meshRatio = _Mesh_Size / _Mesh_Res;
   int FMR = ((int) _Mesh_Res) + 2 * ((int)_MeshOverlap);
   int idx = HeightIdx(FMR, _offset.w, v.vertex.x, v.vertex.z);
   ApplyNormal(v, v.vertex.x, v.vertex.z, _offset.w, FMR);
   [flatten] if (_offset.y < -5000){
      v.vertex.y = 0;
      v.vertex.x = 0;
      v.vertex.z = 0;
   } else {
      v.vertex.y = clamp((_TerrainValues[idx] * _Height) + _offset.y, 0 , .999 * _Height);
      v.vertex.x = (v.vertex.x * meshRatio) + _offset.x - ( _MeshOverlap * meshRatio);
      v.vertex.z = (v.vertex.z * meshRatio) + _offset.z - (_MeshOverlap * meshRatio);   
   }
   
}

// Hooks into microsplat_terrain_body.txt
//  @ SurfImpl(Input i, float3 worldNormalVertex)
// into the very beginning of the method

// #if _MM2HEIGHT
//    MapMagicTerrainNormal(i);
// #endif

void MapMagicTerrainNormal(inout Input i){
   i.worldPos = i.worldPos / 1000;
   i.uv_Control0 = i.worldPos.xz;
}